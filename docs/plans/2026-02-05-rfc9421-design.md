# RFC9421 HTTP Message Signatures Design

## Overview

Add support for RFC9421 (HTTP Message Signatures) to verify incoming requests and sign outgoing requests.

## Use Cases

- **Primary:** Verify incoming requests signed by clients
- **Secondary:** Sign outgoing HTTP requests to external services

## Architecture

```
src/
├── middleware/
│   ├── http-signature/
│   │   ├── index.ts                 # Public API: httpSig() middleware
│   │   ├── types.ts                 # TypeScript interfaces
│   │   ├── verify.ts                # Signature verification logic
│   │   ├── sign.ts                  # Outgoing request signing
│   │   ├── algorithms/
│   │   │   ├── index.ts             # Algorithm registry
│   │   │   ├── rsa-pss-sha512.ts    # RSA-PSS implementation
│   │   │   └── rsa-v1_5-sha256.ts   # RSASSA-PKCS1-v1_5
│   │   ├── components.ts            # Derived component extraction
│   │   ├── signature-base.ts        # Signature base string construction
│   │   └── jwks.ts                  # JWKS key resolution
```

### Design Decisions

- **Reuse `jose`** for cryptographic operations and JWKS fetching (already a dependency)
- **Algorithm registry pattern** for easy extensibility
- **Separate verify/sign modules** so consumers can import only what they need
- **Fastify-native** using preHandler hooks like existing `jwtAuth`

## Public API

### Verification Middleware

```typescript
// Basic usage - require signature with default components
@Get('/secure', httpSig())

// Specify required signed components
@Post('/data', httpSig({
  required: ['content-digest', 'content-type', 'date']
}))

// Full options
@Post('/strict', httpSig({
  required: ['@method', '@target-uri', 'content-digest', 'authorization'],
  jwksUrl: 'https://client.example/.well-known/jwks.json',
  maxAge: 300,
  algorithms: ['rsa-pss-sha512', 'rsa-v1_5-sha256'],
}))
```

#### Defaults

- Required components: `@method`, `@target-uri`, `@authority`
- JWKS URL: from environment variable `HTTP_SIG_JWKS_URL`
- Max age: 300 seconds (5 minutes)
- Algorithms: all registered algorithms allowed

#### Request Decoration

On success, attaches parsed signature info to `request.httpSignature`:
- Key ID
- Algorithm used
- Verified components

### Signing Outgoing Requests

```typescript
import { createSigner } from '@/middleware/http-signature/sign';

const signer = createSigner({
  keyId: 'my-service-key',
  privateKey: process.env.HTTP_SIG_PRIVATE_KEY,
  algorithm: 'rsa-pss-sha512',
  components: ['@method', '@target-uri', 'content-digest', 'date'],
});

const headers = await signer.sign({
  method: 'POST',
  url: 'https://partner.example/api/resource',
  headers: { 'Content-Type': 'application/json', 'Date': new Date().toUTCString() },
  body: JSON.stringify({ data: 'value' }),
});

await fetch('https://partner.example/api/resource', {
  method: 'POST',
  headers,
  body: JSON.stringify({ data: 'value' }),
});
```

## Verification Flow

1. **Parse headers** - Extract `Signature` and `Signature-Input` headers
2. **Validate requirements** - Check all required components are covered
3. **Build signature base** - Reconstruct canonical string that was signed
4. **Resolve key** - Fetch JWKS, find key matching `keyid` parameter
5. **Verify signature** - Use specified algorithm to verify
6. **Check freshness** - Verify `created` timestamp within `maxAge` window

### Signature Base Example

```
"@method": POST
"@target-uri": /api/data
"content-digest": sha-256=:X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=:
"@signature-params": ("@method" "@target-uri" "content-digest");keyid="client-key-1";alg="rsa-pss-sha512";created=1704067200
```

## Error Handling

Following RFC9421 recommendations with proper challenge headers.

### Missing Signature (401)

```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Signature realm="api", headers="@method @target-uri content-digest"
Content-Type: application/json

{"error": "signature_required", "message": "Request signature required"}
```

### Invalid/Expired Signature (401)

```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Signature realm="api", error="invalid_signature"
Content-Type: application/json

{"error": "invalid_signature", "message": "Signature verification failed"}
```

### Missing Required Components (401)

```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Signature realm="api", error="missing_components", headers="content-digest date"
Content-Type: application/json

{"error": "missing_components", "message": "Signature must cover: content-digest, date"}
```

### Logging

Errors logged at `warn` level with details (key ID, algorithm, failure reason). Sensitive data (signature values, keys) is never logged.

## Algorithm Extensibility

### Registry Interface

```typescript
export interface SignatureAlgorithm {
  name: string;
  verify(publicKey: KeyLike, signature: Uint8Array, data: Uint8Array): Promise<boolean>;
  sign(privateKey: KeyLike, data: Uint8Array): Promise<Uint8Array>;
}

const registry = new Map<string, SignatureAlgorithm>();

export function registerAlgorithm(algo: SignatureAlgorithm) {
  registry.set(algo.name, algo);
}

export function getAlgorithm(name: string): SignatureAlgorithm | undefined {
  return registry.get(name);
}
```

### Built-in Algorithms

- `rsa-pss-sha512` - RSA-PSS with SHA-512
- `rsa-v1_5-sha256` - RSASSA-PKCS1-v1_5 with SHA-256

### Adding New Algorithms

```typescript
// src/middleware/http-signature/algorithms/ecdsa-p256.ts
import { registerAlgorithm } from './index';

registerAlgorithm({
  name: 'ecdsa-p256-sha256',
  async verify(publicKey, signature, data) {
    // Implementation using jose
  },
  async sign(privateKey, data) {
    // Implementation using jose
  },
});
```

## Configuration

### Environment Variables

| Variable | Required | Purpose |
|----------|----------|---------|
| `HTTP_SIG_JWKS_URL` | Yes (for verify) | JWKS endpoint for client public keys |
| `HTTP_SIG_PRIVATE_KEY` | For signing | PEM-encoded private key |
| `HTTP_SIG_KEY_ID` | For signing | Your key ID in your JWKS |
| `HTTP_SIG_ALGORITHM` | No | Default algorithm (defaults to `rsa-pss-sha512`) |
| `HTTP_SIG_MAX_AGE` | No | Signature freshness window in seconds (defaults to 300) |

### Config Integration

```typescript
// Added to src/config/index.ts
httpSignature: {
  jwksUrl: process.env.HTTP_SIG_JWKS_URL,
  privateKey: process.env.HTTP_SIG_PRIVATE_KEY,
  keyId: process.env.HTTP_SIG_KEY_ID,
  defaultAlgorithm: process.env.HTTP_SIG_ALGORITHM || 'rsa-pss-sha512',
  maxAge: parseInt(process.env.HTTP_SIG_MAX_AGE || '300', 10),
}
```

JWKS is lazily initialized on first request.

## Testing Strategy

### Test Structure

```
test/
├── middleware/
│   └── http-signature/
│       ├── verify.test.ts
│       ├── sign.test.ts
│       ├── components.test.ts
│       ├── signature-base.test.ts
│       └── integration.test.ts
```

### Verification Tests

- Valid signature passes
- Missing `Signature` header returns 401 with challenge
- Missing required components returns 401
- Expired signature (beyond maxAge) returns 401
- Unknown keyId returns 401
- Tampered body fails content-digest check
- Algorithm not in allowlist rejected

### Signing Tests

- Produces valid `Signature` and `Signature-Input` headers
- Content-Digest computed correctly for body
- All specified components included

### Mocking

Mock JWKS fetch and crypto verification (similar to existing `jose` mocks) to test logic in isolation.

## Signed Components

### Derived Components (RFC9421)

- `@method` - HTTP method (GET, POST, etc.)
- `@target-uri` - Full request URI
- `@authority` - Host header value
- `@scheme` - URL scheme (http/https)
- `@path` - URL path
- `@query` - Query string

### Headers

- `content-digest` - Hash of request body
- `content-type` - Media type
- `content-length` - Body length
- `authorization` - Auth header (if present)
- `date` - Request timestamp
- Custom headers as needed
